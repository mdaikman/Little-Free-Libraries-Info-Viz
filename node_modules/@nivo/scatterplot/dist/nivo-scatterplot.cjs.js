'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var react = require('react');
var core = require('@nivo/core');
var axes = require('@nivo/axes');
var legends = require('@nivo/legends');
var colors = require('@nivo/colors');
var scales = require('@nivo/scales');
var annotations = require('@nivo/annotations');
var get = _interopDefault(require('lodash/get'));
var isString = _interopDefault(require('lodash/isString'));
var isNumber = _interopDefault(require('lodash/isNumber'));
var isPlainObject = _interopDefault(require('lodash/isPlainObject'));
var d3Scale = require('d3-scale');
var web = require('@react-spring/web');
var jsxRuntime = require('react/jsx-runtime');
var tooltip = require('@nivo/tooltip');
var voronoi = require('@nivo/voronoi');

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

var isDynamicSizeSpec = function isDynamicSizeSpec(size) {
  return isPlainObject(size);
};

var getNodeSizeGenerator = function getNodeSizeGenerator(size) {
  if (typeof size === 'function') return size;
  if (isNumber(size)) return function () {
    return size;
  };

  if (isDynamicSizeSpec(size)) {
    if (!isString(size.key)) {
      throw new Error('symbolSize is invalid, key should be a string pointing to the property to use to determine node size');
    }

    if (!Array.isArray(size.values) || size.values.length !== 2) {
      throw new Error('symbolSize is invalid, values spec should be an array containing two values, min and max');
    }

    if (!Array.isArray(size.sizes) || size.sizes.length !== 2) {
      throw new Error('symbolSize is invalid, sizes spec should be an array containing two values, min and max');
    }

    var sizeScale = d3Scale.scaleLinear().domain([size.values[0], size.values[1]]).range([size.sizes[0], size.sizes[1]]);
    return function (datum) {
      return sizeScale(get(datum, size.key));
    };
  }

  throw new Error('nodeSize is invalid, it should be either a function, a number or an object');
};
var computePoints = function computePoints(_ref) {
  var series = _ref.series,
      formatX = _ref.formatX,
      formatY = _ref.formatY,
      getNodeId = _ref.getNodeId;
  var points = [];
  series.forEach(function (serie) {
    serie.data.forEach(function (d, serieIndex) {
      var point = {
        index: points.length,
        serieIndex: serieIndex,
        serieId: serie.id,
        x: d.position.x,
        xValue: d.data.x,
        formattedX: formatX(d.data.x),
        y: d.position.y,
        yValue: d.data.y,
        formattedY: formatY(d.data.y),
        data: d.data
      };
      points.push(_objectSpread2(_objectSpread2({}, point), {}, {
        id: getNodeId(point)
      }));
    });
  });
  return points;
};

var useNodeSize = function useNodeSize(size) {
  return react.useMemo(function () {
    return getNodeSizeGenerator(size);
  }, [size]);
};

var useScatterPlot = function useScatterPlot(_ref) {
  var data = _ref.data,
      xScaleSpec = _ref.xScaleSpec,
      xFormat = _ref.xFormat,
      yScaleSpec = _ref.yScaleSpec,
      yFormat = _ref.yFormat,
      width = _ref.width,
      height = _ref.height,
      nodeId = _ref.nodeId,
      nodeSize = _ref.nodeSize,
      colors$1 = _ref.colors;

  var _useMemo = react.useMemo(function () {
    return scales.computeXYScalesForSeries(data, xScaleSpec, yScaleSpec, width, height);
  }, [data, xScaleSpec, yScaleSpec, width, height]),
      series = _useMemo.series,
      xScale = _useMemo.xScale,
      yScale = _useMemo.yScale;

  var formatX = core.useValueFormatter(xFormat);
  var formatY = core.useValueFormatter(yFormat);
  var getNodeId = core.usePropertyAccessor(nodeId);
  var rawNodes = react.useMemo(function () {
    return computePoints({
      series: series,
      formatX: formatX,
      formatY: formatY,
      getNodeId: getNodeId
    });
  }, [series, formatX, formatY, getNodeId]);
  var getNodeSize = useNodeSize(nodeSize);
  var getColor = colors.useOrdinalColorScale(colors$1, 'serieId');
  var nodes = react.useMemo(function () {
    return rawNodes.map(function (rawNode) {
      return _objectSpread2(_objectSpread2({}, rawNode), {}, {
        size: getNodeSize(rawNode),
        color: getColor({
          serieId: rawNode.serieId
        })
      });
    });
  }, [rawNodes, getNodeSize, getColor]);
  var legendData = react.useMemo(function () {
    return series.map(function (serie) {
      return {
        id: serie.id,
        label: serie.id,
        color: getColor({
          serieId: serie.id
        })
      };
    });
  }, [series, getColor]);
  return {
    xScale: xScale,
    yScale: yScale,
    nodes: nodes,
    legendData: legendData
  };
};
var useScatterPlotAnnotations = function useScatterPlotAnnotations(items, annotations$1) {
  return annotations.useAnnotations({
    data: items,
    annotations: annotations$1,
    getPosition: function getPosition(node) {
      return {
        x: node.x,
        y: node.y
      };
    },
    getDimensions: function getDimensions(node) {
      return {
        size: node.size,
        width: node.size,
        height: node.size
      };
    }
  });
};

var interpolateRadius = function interpolateRadius(size) {
  return size / 2;
};

var Node = function Node(_ref) {
  var node = _ref.node,
      style = _ref.style,
      blendMode = _ref.blendMode,
      isInteractive = _ref.isInteractive,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick;
  var handleMouseEnter = react.useCallback(function (event) {
    return onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(node, event);
  }, [node, onMouseEnter]);
  var handleMouseMove = react.useCallback(function (event) {
    return onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(node, event);
  }, [node, onMouseMove]);
  var handleMouseLeave = react.useCallback(function (event) {
    return onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(node, event);
  }, [node, onMouseLeave]);
  var handleClick = react.useCallback(function (event) {
    return onClick === null || onClick === void 0 ? void 0 : onClick(node, event);
  }, [node, onClick]);
  return jsxRuntime.jsx(web.animated.circle, {
    cx: style.x,
    cy: style.y,
    r: style.size.to(interpolateRadius),
    fill: style.color,
    style: {
      mixBlendMode: blendMode
    },
    onMouseEnter: isInteractive ? handleMouseEnter : undefined,
    onMouseMove: isInteractive ? handleMouseMove : undefined,
    onMouseLeave: isInteractive ? handleMouseLeave : undefined,
    onClick: isInteractive ? handleClick : undefined
  });
};

var Tooltip = function Tooltip(_ref) {
  var node = _ref.node;
  return jsxRuntime.jsx(tooltip.BasicTooltip, {
    id: node.serieId,
    value: "x: ".concat(node.formattedX, ", y: ").concat(node.formattedY),
    enableChip: true,
    color: node.color
  });
};

var commonDefaultProps = {
  xScale: {
    type: 'linear',
    min: 0,
    max: 'auto'
  },
  yScale: {
    type: 'linear',
    min: 0,
    max: 'auto'
  },
  enableGridX: true,
  enableGridY: true,
  axisBottom: {},
  axisLeft: {},
  nodeId: function (_ref) {
    var serieId = _ref.serieId,
        index = _ref.index;
    return "".concat(serieId, ".").concat(index);
  },
  nodeSize: 9,
  nodeComponent: Node,
  colors: {
    scheme: 'nivo'
  },
  isInteractive: true,
  debugMesh: false,
  tooltip: Tooltip,
  markers: [],
  legends: [],
  annotations: []
};
var svgDefaultProps = _objectSpread2(_objectSpread2({}, commonDefaultProps), {}, {
  blendMode: 'normal',
  layers: ['grid', 'axes', 'nodes', 'markers', 'mesh', 'legends', 'annotations'],
  role: 'img',
  useMesh: true,
  animate: true,
  motionConfig: 'default'
});
var canvasDefaultProps = _objectSpread2(_objectSpread2({}, commonDefaultProps), {}, {
  layers: ['grid', 'axes', 'nodes', 'mesh', 'legends', 'annotations'],
  pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,
  renderNode: function renderNode(ctx, node) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, node.size / 2, 0, 2 * Math.PI);
    ctx.fillStyle = node.color;
    ctx.fill();
  }
});

var ScatterPlotAnnotations = function ScatterPlotAnnotations(_ref) {
  var nodes = _ref.nodes,
      annotations$1 = _ref.annotations;
  var boundAnnotations = useScatterPlotAnnotations(nodes, annotations$1);
  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: boundAnnotations.map(function (annotation, i) {
      return jsxRuntime.jsx(annotations.Annotation, _objectSpread2({}, annotation), i);
    })
  });
};

var getNodeKey = function getNodeKey(node) {
  return node.id;
};

var regularTransition = function regularTransition(node) {
  return {
    x: node.x,
    y: node.y,
    size: node.size,
    color: node.color
  };
};

var leaveTransition = function leaveTransition(node) {
  return {
    x: node.x,
    y: node.y,
    size: 0,
    color: node.color
  };
};

var Nodes = function Nodes(_ref) {
  var nodes = _ref.nodes,
      nodeComponent = _ref.nodeComponent,
      isInteractive = _ref.isInteractive,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      tooltip$1 = _ref.tooltip,
      blendMode = _ref.blendMode;

  var _useMotionConfig = core.useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var transition = web.useTransition(nodes, {
    keys: getNodeKey,
    from: regularTransition,
    enter: regularTransition,
    update: regularTransition,
    leave: leaveTransition,
    config: springConfig,
    immediate: !animate
  });

  var _useTooltip = tooltip.useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseEnter = react.useCallback(function (node, event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(node, event);
  }, [tooltip$1, showTooltipFromEvent, onMouseEnter]);
  var handleMouseMove = react.useCallback(function (node, event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event);
    onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(node, event);
  }, [tooltip$1, showTooltipFromEvent, onMouseMove]);
  var handleMouseLeave = react.useCallback(function (node, event) {
    hideTooltip();
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(node, event);
  }, [hideTooltip, onMouseLeave]);
  var handleClick = react.useCallback(function (node, event) {
    return onClick === null || onClick === void 0 ? void 0 : onClick(node, event);
  }, [onClick]);
  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: transition(function (style, node) {
      return react.createElement(nodeComponent, {
        node: node,
        style: style,
        blendMode: blendMode,
        isInteractive: isInteractive,
        onMouseEnter: isInteractive ? handleMouseEnter : undefined,
        onMouseMove: isInteractive ? handleMouseMove : undefined,
        onMouseLeave: isInteractive ? handleMouseLeave : undefined,
        onClick: isInteractive ? handleClick : undefined
      });
    })
  });
};

var Mesh = function Mesh(_ref) {
  var nodes = _ref.nodes,
      width = _ref.width,
      height = _ref.height,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      tooltip$1 = _ref.tooltip,
      debug = _ref.debug;

  var _useTooltip = tooltip.useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseEnter = react.useCallback(function (node, event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event);
    onMouseEnter && onMouseEnter(node, event);
  }, [showTooltipFromEvent, tooltip$1, onMouseEnter]);
  var handleMouseMove = react.useCallback(function (node, event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event);
    onMouseMove && onMouseMove(node, event);
  }, [showTooltipFromEvent, tooltip$1, onMouseMove]);
  var handleMouseLeave = react.useCallback(function (node, event) {
    hideTooltip();
    onMouseLeave && onMouseLeave(node, event);
  }, [hideTooltip, onMouseLeave]);
  var handleClick = react.useCallback(function (node, event) {
    onClick && onClick(node, event);
  }, [onClick]);
  return jsxRuntime.jsx(voronoi.Mesh, {
    nodes: nodes,
    width: width,
    height: height,
    onMouseEnter: handleMouseEnter,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    debug: debug
  });
};

var InnerScatterPlot = function InnerScatterPlot(_ref) {
  var data = _ref.data,
      _ref$xScale = _ref.xScale,
      xScaleSpec = _ref$xScale === void 0 ? svgDefaultProps.xScale : _ref$xScale,
      xFormat = _ref.xFormat,
      _ref$yScale = _ref.yScale,
      yScaleSpec = _ref$yScale === void 0 ? svgDefaultProps.yScale : _ref$yScale,
      yFormat = _ref.yFormat,
      width = _ref.width,
      height = _ref.height,
      partialMargin = _ref.margin,
      _ref$layers = _ref.layers,
      layers = _ref$layers === void 0 ? svgDefaultProps.layers : _ref$layers,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? svgDefaultProps.colors : _ref$colors,
      _ref$blendMode = _ref.blendMode,
      blendMode = _ref$blendMode === void 0 ? svgDefaultProps.blendMode : _ref$blendMode,
      _ref$nodeId = _ref.nodeId,
      nodeId = _ref$nodeId === void 0 ? svgDefaultProps.nodeId : _ref$nodeId,
      _ref$nodeSize = _ref.nodeSize,
      nodeSize = _ref$nodeSize === void 0 ? svgDefaultProps.nodeSize : _ref$nodeSize,
      _ref$nodeComponent = _ref.nodeComponent,
      nodeComponent = _ref$nodeComponent === void 0 ? svgDefaultProps.nodeComponent : _ref$nodeComponent,
      _ref$enableGridX = _ref.enableGridX,
      enableGridX = _ref$enableGridX === void 0 ? svgDefaultProps.enableGridX : _ref$enableGridX,
      _ref$enableGridY = _ref.enableGridY,
      enableGridY = _ref$enableGridY === void 0 ? svgDefaultProps.enableGridY : _ref$enableGridY,
      gridXValues = _ref.gridXValues,
      gridYValues = _ref.gridYValues,
      axisTop = _ref.axisTop,
      axisRight = _ref.axisRight,
      _ref$axisBottom = _ref.axisBottom,
      axisBottom = _ref$axisBottom === void 0 ? svgDefaultProps.axisBottom : _ref$axisBottom,
      _ref$axisLeft = _ref.axisLeft,
      axisLeft = _ref$axisLeft === void 0 ? svgDefaultProps.axisLeft : _ref$axisLeft,
      _ref$annotations = _ref.annotations,
      annotations = _ref$annotations === void 0 ? svgDefaultProps.annotations : _ref$annotations,
      _ref$isInteractive = _ref.isInteractive,
      isInteractive = _ref$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref$isInteractive,
      _ref$useMesh = _ref.useMesh,
      useMesh = _ref$useMesh === void 0 ? svgDefaultProps.useMesh : _ref$useMesh,
      _ref$debugMesh = _ref.debugMesh,
      debugMesh = _ref$debugMesh === void 0 ? svgDefaultProps.debugMesh : _ref$debugMesh,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      _ref$tooltip = _ref.tooltip,
      tooltip = _ref$tooltip === void 0 ? svgDefaultProps.tooltip : _ref$tooltip,
      _ref$markers = _ref.markers,
      markers = _ref$markers === void 0 ? svgDefaultProps.markers : _ref$markers,
      _ref$legends = _ref.legends,
      legends$1 = _ref$legends === void 0 ? svgDefaultProps.legends : _ref$legends,
      _ref$role = _ref.role,
      role = _ref$role === void 0 ? svgDefaultProps.role : _ref$role,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      ariaDescribedBy = _ref.ariaDescribedBy;

  var _useDimensions = core.useDimensions(width, height, partialMargin),
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight,
      outerWidth = _useDimensions.outerWidth,
      outerHeight = _useDimensions.outerHeight;

  var _useScatterPlot = useScatterPlot({
    data: data,
    xScaleSpec: xScaleSpec,
    xFormat: xFormat,
    yScaleSpec: yScaleSpec,
    yFormat: yFormat,
    width: innerWidth,
    height: innerHeight,
    nodeId: nodeId,
    nodeSize: nodeSize,
    colors: colors
  }),
      xScale = _useScatterPlot.xScale,
      yScale = _useScatterPlot.yScale,
      nodes = _useScatterPlot.nodes,
      legendData = _useScatterPlot.legendData;

  var customLayerProps = react.useMemo(function () {
    return {
      xScale: xScale,
      yScale: yScale,
      nodes: nodes,
      margin: margin,
      innerWidth: innerWidth,
      innerHeight: innerHeight,
      outerWidth: outerWidth,
      outerHeight: outerHeight
    };
  }, [xScale, yScale, nodes, margin, innerWidth, innerHeight, outerWidth, outerHeight]);
  var layerById = {
    grid: null,
    axes: null,
    nodes: null,
    markers: null,
    mesh: null,
    annotations: null,
    legends: null
  };

  if (layers.includes('grid')) {
    layerById.grid = jsxRuntime.jsx(axes.Grid, {
      width: innerWidth,
      height: innerHeight,
      xScale: enableGridX ? xScale : null,
      yScale: enableGridY ? yScale : null,
      xValues: gridXValues,
      yValues: gridYValues
    }, "grid");
  }

  if (layers.includes('axes')) {
    layerById.axes = jsxRuntime.jsx(axes.Axes, {
      xScale: xScale,
      yScale: yScale,
      width: innerWidth,
      height: innerHeight,
      top: axisTop,
      right: axisRight,
      bottom: axisBottom,
      left: axisLeft
    }, "axes");
  }

  if (layers.includes('nodes')) {
    layerById.nodes = jsxRuntime.jsx(Nodes, {
      nodes: nodes,
      nodeComponent: nodeComponent,
      isInteractive: isInteractive,
      tooltip: tooltip,
      blendMode: blendMode,
      onMouseEnter: onMouseEnter,
      onMouseMove: onMouseMove,
      onMouseLeave: onMouseLeave,
      onClick: onClick
    }, "nodes");
  }

  if (layers.includes('markers')) {
    layerById.markers = jsxRuntime.jsx(core.CartesianMarkers, {
      markers: markers,
      width: innerWidth,
      height: innerHeight,
      xScale: xScale,
      yScale: yScale
    }, "markers");
  }

  if (layers.includes('mesh') && isInteractive && useMesh) {
    layerById.mesh = jsxRuntime.jsx(Mesh, {
      nodes: nodes,
      width: innerWidth,
      height: innerHeight,
      onMouseEnter: onMouseEnter,
      onMouseMove: onMouseMove,
      onMouseLeave: onMouseLeave,
      onClick: onClick,
      tooltip: tooltip,
      debug: debugMesh
    }, "mesh");
  }

  if (layers.includes('annotations')) {
    layerById.annotations = jsxRuntime.jsx(ScatterPlotAnnotations, {
      nodes: nodes,
      annotations: annotations
    }, "annotations");
  }

  if (layers.includes('legends')) {
    layerById.legends = legends$1.map(function (legend, i) {
      return jsxRuntime.jsx(legends.BoxLegendSvg, _objectSpread2(_objectSpread2({}, legend), {}, {
        containerWidth: innerWidth,
        containerHeight: innerHeight,
        data: legendData
      }), i);
    });
  }

  return jsxRuntime.jsx(core.SvgWrapper, {
    width: outerWidth,
    height: outerHeight,
    margin: margin,
    role: role,
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    ariaDescribedBy: ariaDescribedBy,
    children: layers.map(function (layer, i) {
      if (typeof layer === 'string' && layerById[layer] !== undefined) {
        return layerById[layer];
      }

      if (typeof layer === 'function') {
        return jsxRuntime.jsx(react.Fragment, {
          children: react.createElement(layer, customLayerProps)
        }, i);
      }

      throw new Error("Unknown layer (".concat(layer, ")"));
    })
  });
};

var ScatterPlot = function ScatterPlot(_ref2) {
  var _ref2$isInteractive = _ref2.isInteractive,
      isInteractive = _ref2$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref2$isInteractive,
      _ref2$animate = _ref2.animate,
      animate = _ref2$animate === void 0 ? svgDefaultProps.animate : _ref2$animate,
      _ref2$motionConfig = _ref2.motionConfig,
      motionConfig = _ref2$motionConfig === void 0 ? svgDefaultProps.motionConfig : _ref2$motionConfig,
      theme = _ref2.theme,
      renderWrapper = _ref2.renderWrapper,
      otherProps = _objectWithoutProperties(_ref2, ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"]);

  return jsxRuntime.jsx(core.Container, {
    animate: animate,
    isInteractive: isInteractive,
    motionConfig: motionConfig,
    renderWrapper: renderWrapper,
    theme: theme,
    children: jsxRuntime.jsx(InnerScatterPlot, _objectSpread2({
      isInteractive: isInteractive
    }, otherProps))
  });
};

var ResponsiveScatterPlot = function ResponsiveScatterPlot(props) {
  return jsxRuntime.jsx(core.ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsxRuntime.jsx(ScatterPlot, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var InnerScatterPlotCanvas = function InnerScatterPlotCanvas(_ref) {
  var data = _ref.data,
      _ref$xScale = _ref.xScale,
      xScaleSpec = _ref$xScale === void 0 ? canvasDefaultProps.xScale : _ref$xScale,
      xFormat = _ref.xFormat,
      _ref$yScale = _ref.yScale,
      yScaleSpec = _ref$yScale === void 0 ? canvasDefaultProps.yScale : _ref$yScale,
      yFormat = _ref.yFormat,
      width = _ref.width,
      height = _ref.height,
      partialMargin = _ref.margin,
      _ref$pixelRatio = _ref.pixelRatio,
      pixelRatio = _ref$pixelRatio === void 0 ? canvasDefaultProps.pixelRatio : _ref$pixelRatio,
      _ref$layers = _ref.layers,
      layers = _ref$layers === void 0 ? canvasDefaultProps.layers : _ref$layers,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? canvasDefaultProps.colors : _ref$colors,
      _ref$nodeId = _ref.nodeId,
      nodeId = _ref$nodeId === void 0 ? svgDefaultProps.nodeId : _ref$nodeId,
      _ref$nodeSize = _ref.nodeSize,
      nodeSize = _ref$nodeSize === void 0 ? canvasDefaultProps.nodeSize : _ref$nodeSize,
      _ref$renderNode = _ref.renderNode,
      renderNode = _ref$renderNode === void 0 ? canvasDefaultProps.renderNode : _ref$renderNode,
      _ref$enableGridX = _ref.enableGridX,
      enableGridX = _ref$enableGridX === void 0 ? canvasDefaultProps.enableGridX : _ref$enableGridX,
      gridXValues = _ref.gridXValues,
      _ref$enableGridY = _ref.enableGridY,
      enableGridY = _ref$enableGridY === void 0 ? canvasDefaultProps.enableGridY : _ref$enableGridY,
      gridYValues = _ref.gridYValues,
      axisTop = _ref.axisTop,
      axisRight = _ref.axisRight,
      _ref$axisBottom = _ref.axisBottom,
      axisBottom = _ref$axisBottom === void 0 ? canvasDefaultProps.axisBottom : _ref$axisBottom,
      _ref$axisLeft = _ref.axisLeft,
      axisLeft = _ref$axisLeft === void 0 ? canvasDefaultProps.axisLeft : _ref$axisLeft,
      _ref$annotations = _ref.annotations,
      annotations$1 = _ref$annotations === void 0 ? canvasDefaultProps.annotations : _ref$annotations,
      _ref$isInteractive = _ref.isInteractive,
      isInteractive = _ref$isInteractive === void 0 ? canvasDefaultProps.isInteractive : _ref$isInteractive,
      _ref$debugMesh = _ref.debugMesh,
      debugMesh = _ref$debugMesh === void 0 ? canvasDefaultProps.debugMesh : _ref$debugMesh,
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      _ref$tooltip = _ref.tooltip,
      tooltip$1 = _ref$tooltip === void 0 ? canvasDefaultProps.tooltip : _ref$tooltip,
      _ref$legends = _ref.legends,
      legends$1 = _ref$legends === void 0 ? canvasDefaultProps.legends : _ref$legends;
  var canvasEl = react.useRef(null);
  var theme = core.useTheme();

  var _useState = react.useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      currentNode = _useState2[0],
      setCurrentNode = _useState2[1];

  var _useDimensions = core.useDimensions(width, height, partialMargin),
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight,
      outerWidth = _useDimensions.outerWidth,
      outerHeight = _useDimensions.outerHeight;

  var _useScatterPlot = useScatterPlot({
    data: data,
    xScaleSpec: xScaleSpec,
    xFormat: xFormat,
    yScaleSpec: yScaleSpec,
    yFormat: yFormat,
    width: innerWidth,
    height: innerHeight,
    nodeId: nodeId,
    nodeSize: nodeSize,
    colors: colors
  }),
      xScale = _useScatterPlot.xScale,
      yScale = _useScatterPlot.yScale,
      nodes = _useScatterPlot.nodes,
      legendData = _useScatterPlot.legendData;

  var boundAnnotations = useScatterPlotAnnotations(nodes, annotations$1);

  var _useVoronoiMesh = voronoi.useVoronoiMesh({
    points: nodes,
    width: innerWidth,
    height: innerHeight,
    debug: debugMesh
  }),
      delaunay = _useVoronoiMesh.delaunay,
      voronoi$1 = _useVoronoiMesh.voronoi;

  var customLayerProps = react.useMemo(function () {
    return {
      xScale: xScale,
      yScale: yScale,
      nodes: nodes,
      margin: margin,
      innerWidth: innerWidth,
      innerHeight: innerHeight,
      outerWidth: outerWidth,
      outerHeight: outerHeight
    };
  }, [xScale, yScale, nodes, margin, innerWidth, innerHeight, outerWidth, outerHeight]);
  react.useEffect(function () {
    if (!canvasEl.current) return;
    canvasEl.current.width = outerWidth * pixelRatio;
    canvasEl.current.height = outerHeight * pixelRatio;
    var ctx = canvasEl.current.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    ctx.fillStyle = theme.background;
    ctx.fillRect(0, 0, outerWidth, outerHeight);
    ctx.translate(margin.left, margin.top);
    layers.forEach(function (layer) {
      if (layer === 'grid') {
        ctx.lineWidth = theme.grid.line.strokeWidth;
        ctx.strokeStyle = theme.grid.line.stroke;
        enableGridX && axes.renderGridLinesToCanvas(ctx, {
          width: innerWidth,
          height: innerHeight,
          scale: xScale,
          axis: 'x',
          values: gridXValues
        });
        enableGridY && axes.renderGridLinesToCanvas(ctx, {
          width: innerWidth,
          height: innerHeight,
          scale: yScale,
          axis: 'y',
          values: gridYValues
        });
      } else if (layer === 'annotations') {
        annotations.renderAnnotationsToCanvas(ctx, {
          annotations: boundAnnotations,
          theme: theme
        });
      } else if (layer === 'axes') {
        axes.renderAxesToCanvas(ctx, {
          xScale: xScale,
          yScale: yScale,
          width: innerWidth,
          height: innerHeight,
          top: axisTop,
          right: axisRight,
          bottom: axisBottom,
          left: axisLeft,
          theme: theme
        });
      } else if (layer === 'nodes') {
        nodes.forEach(function (node) {
          renderNode(ctx, node);
        });
      } else if (layer === 'mesh') {
        if (debugMesh === true) {
          voronoi.renderVoronoiToCanvas(ctx, voronoi$1);

          if (currentNode) {
            voronoi.renderVoronoiCellToCanvas(ctx, voronoi$1, currentNode.index);
          }
        }
      } else if (layer === 'legends') {
        legends$1.forEach(function (legend) {
          legends.renderLegendToCanvas(ctx, _objectSpread2(_objectSpread2({}, legend), {}, {
            data: legendData,
            containerWidth: innerWidth,
            containerHeight: innerHeight,
            theme: theme
          }));
        });
      } else if (typeof layer === 'function') {
        layer(ctx, customLayerProps);
      } else {
        throw new Error("Invalid layer: ".concat(layer));
      }
    });
  }, [canvasEl, innerWidth, innerHeight, outerWidth, outerHeight, margin.top, margin.left, pixelRatio, renderNode, layers, customLayerProps, theme, xScale, yScale, nodes, enableGridX, enableGridY, axisTop, axisRight, axisBottom, axisLeft, legends$1, legendData, debugMesh, voronoi$1, currentNode]);

  var _useTooltip = tooltip.useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var getNodeFromMouseEvent = react.useCallback(function (event) {
    var _getRelativeCursor = core.getRelativeCursor(canvasEl.current, event),
        _getRelativeCursor2 = _slicedToArray(_getRelativeCursor, 2),
        x = _getRelativeCursor2[0],
        y = _getRelativeCursor2[1];

    if (!core.isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null;
    var nodeIndex = delaunay.find(x - margin.left, y - margin.top);
    return nodes[nodeIndex];
  }, [canvasEl, margin, innerWidth, innerHeight, delaunay]);
  var handleMouseHover = react.useCallback(function (event) {
    var node = getNodeFromMouseEvent(event);
    setCurrentNode(node);

    if (node) {
      showTooltipFromEvent(react.createElement(tooltip$1, {
        node: node
      }), event);

      if (currentNode && currentNode.id !== node.id) {
        onMouseLeave && onMouseLeave(currentNode, event);
        onMouseEnter && onMouseEnter(node, event);
      }

      if (!currentNode) {
        onMouseEnter && onMouseEnter(node, event);
      }

      onMouseMove && onMouseMove(node, event);
    } else {
      hideTooltip();
      currentNode && onMouseLeave && onMouseLeave(currentNode, event);
    }
  }, [getNodeFromMouseEvent, currentNode, setCurrentNode, showTooltipFromEvent, hideTooltip, tooltip$1, onMouseEnter, onMouseMove, onMouseLeave]);
  var handleMouseLeave = react.useCallback(function (event) {
    hideTooltip();
    setCurrentNode(null);
    currentNode && onMouseLeave && onMouseLeave(currentNode, event);
  }, [hideTooltip, currentNode, setCurrentNode, onMouseLeave]);
  var handleClick = react.useCallback(function (event) {
    if (onClick) {
      var node = getNodeFromMouseEvent(event);
      node && onClick(node, event);
    }
  }, [getNodeFromMouseEvent, onClick]);
  return jsxRuntime.jsx("canvas", {
    ref: canvasEl,
    width: outerWidth * pixelRatio,
    height: outerHeight * pixelRatio,
    style: {
      width: outerWidth,
      height: outerHeight,
      cursor: isInteractive ? 'auto' : 'normal'
    },
    onMouseEnter: isInteractive ? handleMouseHover : undefined,
    onMouseMove: isInteractive ? handleMouseHover : undefined,
    onMouseLeave: isInteractive ? handleMouseLeave : undefined,
    onClick: isInteractive ? handleClick : undefined
  });
};

var ScatterPlotCanvas = function ScatterPlotCanvas(_ref2) {
  var isInteractive = _ref2.isInteractive,
      renderWrapper = _ref2.renderWrapper,
      theme = _ref2.theme,
      props = _objectWithoutProperties(_ref2, ["isInteractive", "renderWrapper", "theme"]);

  return jsxRuntime.jsx(core.Container, {
    isInteractive: isInteractive,
    renderWrapper: renderWrapper,
    theme: theme,
    animate: false,
    children: jsxRuntime.jsx(InnerScatterPlotCanvas, _objectSpread2({}, props))
  });
};

var ResponsiveScatterPlotCanvas = function ResponsiveScatterPlotCanvas(props) {
  return jsxRuntime.jsx(core.ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsxRuntime.jsx(ScatterPlotCanvas, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

exports.ResponsiveScatterPlot = ResponsiveScatterPlot;
exports.ResponsiveScatterPlotCanvas = ResponsiveScatterPlotCanvas;
exports.ScatterPlot = ScatterPlot;
exports.ScatterPlotCanvas = ScatterPlotCanvas;
exports.canvasDefaultProps = canvasDefaultProps;
exports.commonDefaultProps = commonDefaultProps;
exports.svgDefaultProps = svgDefaultProps;
exports.useScatterPlot = useScatterPlot;
exports.useScatterPlotAnnotations = useScatterPlotAnnotations;
//# sourceMappingURL=nivo-scatterplot.cjs.js.map
